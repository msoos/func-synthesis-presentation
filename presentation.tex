\documentclass[aspectratio=169]{beamer}
\usepackage{amsmath}
\usepackage{algorithmic}
\usepackage{fancyvrb}
\usepackage{framed}
\usepackage{caption}
\usepackage{qrcode}
\usetheme{CambridgeUS}
\usepackage{hyperref}
\newcommand{\bluelink}[2]{\href{#1}{\textcolor{blue}{\textbf{#2}}}}
\usepackage{fancyvrb}
\usepackage{listings}
\usepackage{xcolor}


\title[Func. Synthesis]{
Boolean Functional Synthesis and its possible application to Cryptography}
\author[Soos]{Mate Soos}
\institute[Argot]{\large Argot Collective (\url{https://argot.org})}
\date{8th of July 2025}
\subtitle{COSIC, KU Leuven}

\begin{document}
\begin{frame}
    \titlepage
\end{frame}

\begin{frame}{A bit about myself}
\begin{itemize}
\item PhD from INRIA Grenoble, France
\item Part-time research at Kuldeep Meel's group, authored::
    \begin{itemize}
        \item \textbf{CryptoMiniSat} -- SAT solver with XORs
        \item \textbf{Ganak\&ApproxMC} -- CNF counters
        \item \textbf{Arjun} -- CNF simplifier, also doing functional synthesis
        \item \textbf{Bosphorus} -- ANF simplifier
        \item \textbf{Pepin} -- DNF counter
    \end{itemize}
\item Worked in IT Security for 10+ years: hacking,
    threat modelling, risk management
\item Working at Ethereum Foundation, now Argot Collective for the past $\approx3$
    years: \textbf{hevm}
\end{itemize}
\end{frame}

\begin{frame}{Outline}
    \tableofcontents
\end{frame}

\section{Boolean Functional Synthesis}
% Slide 1: High-Level Overview
\begin{frame}{High-Level Overview}
  \textbf{Boolean Functional Synthesis}:
  \begin{itemize}
    \item Automatically \textbf{constructs Boolean functions} from logical specifications.
    \item Key problem: Given \(\exists \vec{Y}\, \varphi(\vec{X}, \vec{Y})\),
        find Skolem functions \(\vec{\Psi}(\vec{X})\) such that:
        \[
            \forall \vec{X}\, \left( \exists \vec{Y}\, \varphi(\vec{X}, \vec{Y}) \equiv \varphi(\vec{X}, \vec{\Psi}(\vec{X})) \right)
        \]
    \item Typically, \(\varphi\) is a CNF formula
\end{itemize}
\bigskip

Approaches:
\begin{itemize}
    \item \textsc{CadiBack} -- Calculate fixed points of \(\varphi\)
    \item \textsc{Oracle}from \textsc{SharpSAT-TD} -- Find all equivalent variables in \(\varphi\)
    \item \textsc{Unique} -- Based on proofs + interpolation
    \item \textsc{Manthan} -- Based on Guess-and-Repair
    \item \textsc{d4} -- Based on d-DNNF, i.e. model counting
\end{itemize}
\bigskip
\end{frame}

\begin{frame}{Motivation}
Useful for:
\begin{itemize}
    \item \textbf{Circuit Design}: Synthesize gates from declarative specifications.
    \item \textbf{Program Repair}: Generate patches for buggy code.
    \item \textbf{Proposal: Cryptographic Protocols}: Automatically generate sub-functions
\end{itemize}
\end{frame}

\begin{frame}{Example 1}
$\varphi(x_1, x_2, y) = (x_1 \lor y) \land (x_2 \lor \neg y)$
\bigskip

Notice:
\begin{itemize}
    \item When $x_1 = 0$, $y$ must be $1$
    \item When $x_2 = 0$, $y$ must be $0$
    \item When $x_1 = 0$, and $x_2 = 0$, $\varphi$ is UNSAT, so $y$ can be anything $\rightarrow$ it's \textbf{not fully defined}
    \item When $x_1 = 1$, and $x_2 = 1$, then $\varphi = T$ irrespective of $y$ $\rightarrow$ it's \textbf{not fully defined}
\end{itemize}
\bigskip

\textbf{One Solution}: $y = \Psi(x_1, x_2) = \neg x_1 \lor x_2$
\bigskip

This happens to give $y=1$ when both are 0, and $y=1$ when both are 1. There
are 4 skolem functions that satisfy this formula. We could have picked
any.
\end{frame}

\begin{frame}{Example 1 (cont.)}
$\varphi(x_1, x_2, y) = (x_1 \lor y) \land (x_2 \lor \neg y)$
\bigskip

Let's look at the \textbf{truth table} of \(\varphi\):

\begin{tabular}{|c|c|c|c|}
    \hline
    $x_1$ & $x_2$ & $\mathbf{y}$ & $\varphi(x_1, x_2, y)$ \\
    \hline
    0 & 0 & \textbf{X} & F\\
    0 & 1 & 0 & \textbf{F}\\
    0 & 1 & 1 & T\\
    1 & 0 & 0 & T\\
    1 & 0 & 1 & \textbf{F}\\
    1 & 1 & \textbf{X} & T\\
    \hline
\end{tabular}
\end{frame}

\begin{frame}{Example 2}
$\varphi(x_1, y) = (x_1 \lor y) \land (\neg x_1 \lor \neg y)$
\bigskip

Notice:
\begin{itemize}
    \item When $x_1 = 0$, $y$ must be $0$
    \item When $x_1 = 1$, $y$ must be $1$
    \item \textbf{Fully defined}: $y$ is uniquely determined by $x_1$
\end{itemize}
\bigskip

\textbf{Only Solution}: $y = \Psi(x_1) = \neg x_1$
\bigskip

Let's look at the \textbf{truth table} of \(\varphi\):
\begin{tabular}{|c|c|c|}
    \hline
    $x_1$ & $\mathbf{y}$ & $\varphi(x_1, y)$ \\
    \hline
    0 & 0 & T\\
    0 & 1 & \textbf{F}\\
    1 & 0 & T\\
    1 & 1 & \textbf{F}\\
    \hline
\end{tabular}
\end{frame}

\begin{frame}{Basic approach: Piecemeal synthesis}
\begin{itemize}
    \item Iteratively find Skolem functions for each variable
    \item Start with the easiest variable, $y_1$, define purely in terms of $\vec{x}$
    \item The variables already defined can be used to define the other variables
    \item Once $y_1, \ldots y_k$ is defined, $\psi_{k+1}(\vec{x})$ can use $y_1,\ldots y_k$ as an input:
        $y_k=\psi_{k+1}(\vec{x}) =
        \psi_{k+1}(\vec{x}, \psi_1, \ldots \psi_k) =
        \psi_{k+1}(\vec{x}, y_1, \ldots y_k)$
\end{itemize}
\bigskip

\end{frame}

\begin{frame}{How-To: Fully Defined Variables}
\begin{itemize}
    \item Start with a CNF formula $ \varphi$
    \item Identify variables that are forced via backbone detection
        via \textsc{CadiBack}
    \item Identify all equivalent variables via \textsc{Oracle}
        in \textsc{SharpSAT-TD}
    \item Identify fully defined variables via Padoa's Theorem:
        \begin{itemize}
        \item Do quick query to check if $y_k$ is fully defined by $(\vec{x}, \vec{y} \backslash y_k)$
        \item Use \textsc{CaDiCaL} to produce proof of UNSAT
        \item Use McMillan paper's interpolant generation to extract definition
            circuit
        \end{itemize}
\end{itemize}
\bigskip
Avoid cycles above, i.e. it's not good if $y_1$ is defined by $y_2$, and $y_2$
is defined by $y_1$.
\bigskip

Now everything that could be fully defined, is defined. It turns out, this is
the easy part.
\end{frame}


\begin{frame}{How-To: Not Fully Defined Variables}
There are a number of ways to do this:
\begin{itemize}
    \item Guess-and-Repair: \textsc{Manthan} algorithm
        \begin{enumerate}
            \item Get samples, run ML to create decision tree
            \item Compute counterexample, minimize it
            \item Add repair constraints
            \item Goto 2
        \end{enumerate}
    \item 2QBF-based method: \textsc{CADET}, using incremental determinization
    \item BDD-based method: \textsc{RSynth} via \textsc{CUDD}
    \item d-DNNF-based method: \textsc{d4}
    \item Force-eliminate variable (last resort, exponential)
\end{itemize}
\bigskip

It's still early stage research: unknown what's best. Likely a combination.
\end{frame}

\begin{frame}{Thank you for your time!}
    Any questions?
\end{frame}

\end{document}
